<HTML>

<HEAD>
<TITLE> ACEDB source code documentation: programming ace displays </TITLE>

<LINK rel=stylesheet type="text/css"
href="./wdoc.css"
title="Style sheet for wdoc developer documents">

</HEAD>

<BODY>

<H1>Application programmers' guide to ace displays</H1>

<P>This is a prelimininary discussion document. New displays will be
written according to this spec and old ones will gradually be
converted.</P>

<P>We're discussing the window handling, the data structures, their names and their memory handling.</P>

<P>The primary ideas about an ace-display are :</P>

<OL>
 <LI>The window display the data of a specific object.
 <LI>All data calculated about the object is held in a datastructure.
 <LI>This data structure is attached to the window using graphAssociators.
 <LI>The memory of the datastructure has to be re-claimed if the window dies.
 <LI>The graph has to be cleared if the data-structure is destroyed.<BR>
     This may occur, if the handle upon which the datastructure was allocated is destroyed.
</OL>

This is a model of a fictitious display for another Acedb Map :

<PRE>
      +--------------------------+
      |O| AMAP:dj9812          |X|
      +--------------------------+        +-----------------------------------+
      |          =               |        | struct AceMapStruct               |
      |           =_ _  gene     |------> | {                                 |
      |           = - =  unc-1   |        |   &lt;standard struct-members&gt;       |
      | dj9812    =_  =          |        |   &lt;specific struct-members&gt;       |
      |           _-  _          |        | }                                 |
      |           |   -          |        +-----------------------------------+
      |           -   =          |
      +--------------------------+
</PRE>

<P>The way the window and the data-structure is created and destroyed
needs standardization, some of that can hopefully be provided by a set
of wrapper functions in the display-Package.</P>

<H2>The layout of the data-structure and naming conventions :</H2>

<P>Let's assume that the name for this display is "<B>AceMap</B>", another display
along the lines of FMAP or GMAP.</P>

<H3>Magic identifiers and associators</H3>

<P>Every graph has an associator attached : an associator lets you register a void*
upon a unique identifier. This unique identifier is another pointer-type, and we will use
the address of a static string-constant. The unique address of that string is guaranted by the
compiler, which during link-time will fit the constant string within the address-space of the program.
<BR>
When the window is created and it's data-structure filled with appropriate information, the
graphAssociator for the active graph will be registered to return the address of the data-structure
if it is presented with the string's magic address on that window again.
</P>

The magic associator string for our example display would be declared like this :
<PRE>
static magic_t GRAPH2AceMap_ASSOC = "GRAPH2AceMap";
</PRE>

<P>It is because C has very poor type-checking and no generic
 data-types, that the graphAss-package uses <CODE>void*</CODE> as the
 address to the window's data-structure.
<BR>
 The pointer returned by graphAssFind (upon the active graph) has to be
 type-cast from <CODE>void*</CODE> to the type of
 <CODE>AceMapStruct</CODE>. Pointer type-casts are always a
 dangerous thing to do, because the dereferencing of structures is just
 a very crude memory look-up in C.
</P>

<P>Therefore, one of the <B>&lt;standard struct-members&gt;</B> is a
 magic identifier, which is used to verify that the <CODE>void*</CODE>
 pointer is what we expect. After that we know that the type-cast was
 safe and we can derefence the <CODE>void*</CODE> pointer based on the
 struct definition of <CODE>AceMapStruct</CODE>.</P>

<P>The magic identifier is again a unique pointer, generated by the
 compiler as the address to a static string constant. The magic id is
 declared in the following way :</P>

<PRE>
static magic_t AceMap_MAGIC = "AceMap";
</PRE>

One of the standard ace-display struct members is <CODE>-&gt;magic</CODE>
which is assigned to <CODE>&amp;AceMap_MAGIC</CODE> when the data-structure
is created and filled with data.</P>

<H3>Memory handling</H3>

<P>Above we mentioned two goals about the memory handling of
 ace-displays. The graph should be destroyable by the usual
 <CODE>graphDestroy()</CODE> menu-action or a window-managers "CLOSE"
 signal and upon dying the memory of the data-strcuture needs to be
 reclaimed cleanly.  On the other hand we want to be able to create an
 AceMapStruct and destroy it, which should clear up the graph.<P>

<P>The function creating the graph needs to create the data-structure and graphAssociate it with itself.
 The graph's destructor function needs to disassociate the data-structure, with the dying graph
 and clear its memory.</P>

<P>The function creating the data-structure needs to allocate the
 memory of the struct upon a given handle, register the finalisation
 function, assign it's magic identifier, assign the graph to be the
 one we've just opened and fill in all the data.</P>

<P>The window is created by the standard <CODE>DisplayFunc</CODE>,
 whose type is defined in <CODE>acedb.h</CODE> (<I>should move to
 display.h</I>) as</P>

<PRE>
typedef BOOL (*DisplayFunc)(KEY key, KEY from, BOOL isOldDisplay) ;
</PRE>

<P>A window that has a display-function of this type can be registered
 and configured using the wspec/displays.wrm configuration file.</P>

The structure of the AceMap display module so far is :

<PRE>

/*******************************************/

static magic_t GRAPH2AceMap_ASSOC = "GRAPH2AceMap";
static magic_t AceMap_MAGIC = "AceMap";

typedef struct AceMapStruct
{
  /* standard display-struct members */
  magic_t *magic;		/* == &amp;AceMap_MAGIC */
  STORE_HANDLE handle;
  Graph graph;
  KEY originKey;

<I>
  /* AceMap display struct members */
  Array exampleArray;
  char *exampleString;
</I>
} *AceMap;

/*******************************************/

static AceMap currentAceMap (char *caller)
     /* return AceMap structure associated with the active graph */
{
  AceMap amap;

  if (!graphAssFind (&amp;GRAPH2AceMap_ASSOC,&amp;amap))
    messcrash("%s() could not find AceMap on graph", caller);
  if (!amap)
    messcrash("%s() received NULL AceMap pointer", caller);
  if (amap-&gt;magic != &amp;AceMap_MAGIC)
    messcrash("%s() received non-magic AceMap pointer", caller);
  
  return amap;
} /* currentAceMap */

/*******************************************/

static void aceMapFinalise (void *vp)
     /* Finalisation function for AceMap type */
{
  AceMap amap = (AceMap)vp;
  Graph old = graphActive ();

  if (graphActivate (amap-&gt;graph))
    {
      graphDestroy ();	       /* let the graph-destructor do the rest */
      graphActivate (old);
    }
  else
    handleDestroy (amap-&gt;handle);

  return;
} /* aceMapFinalise */

static AceMap aceMapCreate (KEY key, KEY from)
     /* Constructor function for AceMap type */
{
  AceMap amap = NULL;

  if (aceMapPossibleFor(key))
    {
      amap = (AceMap)messalloc(sizeof(struct AceMapStruct));
      blockSetFinalise (amap, aceMapFinalise);
      amap-&gt;magic = &amp;AceMap_MAGIC;
      amap-&gt;handle = handleCreate();
      amap-&gt;graph = 0;
      amap-&gt;originKey = key;
      
<I>
      /* now the AceMap specifics */
      amap-&gt;exampleArray = arrayHandleCreate(10, amap-&gt;handle);
      amap-&gt;exampleString = strnew ("example", amap-&gt;handle);
</I>
    }

  return amap;
} /* aceMapCreate */


static void aceMapDestroy (void)
     /* graph-destructor for AceMap display */
{
  AceMap amap = currentAceMap ("aceMapDestroy");

  amap-&gt;graph = 0;		/* graph is dying already */
  messfree (amap);
} /* aceMapDestroy */


static void aceMapRefresh (void)
{
  AceMap amap = currentAceMap("aceMapRefresh");

  aceMapDraw (amap, 0);

  return;
} /* aceMapRefresh */


static void aceMapDraw (AceMap amap, KEY from)
{
  /* display object amap->originKey, but center on object 'from' */

  return;
} /* aceMapRefresh */


BOOL aceMapDisplay (KEY key, KEY from, BOOL isOldGraph)
     /* graph-constructor for AceMap display */
{
  AceMap amap;

  if (isOldGraph &amp;&amp;
      /* there is a window of type "AceMap already" */
      graphAssFind(&amp;GRAPH2AceMap_ASSOC, &amp;amap) &amp;&amp;
      amap -&gt;magic == &amp;AceMap_MAGIC &amp;&amp;
      amap-&gt;originKey == key)
    {
      /* That existing graph is already showing object we're asking for
	 just redraw for new position based on the 'from'-object */
      aceMapDraw (amap, from);
      return TRUE;
    }

  amap = aceMapCreate (key, from);

  if (!amap)
    {
      /* can't create an AceMap, no data or similar problem
       *  so we show the object in the text display instead */
      display (key, 0, TREE);
      return FALSE;
    }


  /* open new display of type "AceMap" */
  if (!displayCreate ("AceMap"))
    return FALSE;
  
  graphRetitle (name(key));
  graphRegister (RESIZE, aceMapRefresh) ;
  graphRegister (DESTROY, aceMapDestroy) ;

  graphAssociate (&amp;GRAPH2AceMap_ASSOC, amap);
  amap-&gt;graph = graphActive();
  
  aceMapDraw (amap, from);

  return TRUE;
} /* aceMapDisplay */
      
/*******************************************/

</PRE>

</BODY>
</HTML>
